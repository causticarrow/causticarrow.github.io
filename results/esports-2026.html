<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>causticarrow // 2026 esports</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #0d0d0d;
      --bg-card: #161616;
      --bg-header: #1a1a1a;
      --border: #2a2a2a;
      --text: #e6e6e6;
      --text-light: #f0f0f0;
      --text-muted: #999;
      --text-dim: #aaa;
      --positive: #4ade80;
      --negative: #f87171;
      --accent-highlight: rgb(252, 211, 77);
      --accent-separator: rgb(203, 213, 225);
      --cs2-text: rgb(96, 165, 250);
      --cs2-bg: rgb(48, 82, 125);
      --val-text: rgb(251, 146, 60);
      --val-bg: rgb(125, 73, 30);
    }
    body { font-family: "Roboto", system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); padding: 32px; margin: 0; font-size: 15px; }
    .container { max-width: 1400px; margin-left: 300px; padding: 32px; }
    h1 { font-weight: 600; font-size: 30px; color: var(--text-light); margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
    .stats { display: grid; grid-template-columns: repeat(4, minmax(120px, auto)); gap: 16px; margin-bottom: 32px; }
    .stat-box { background: var(--bg-card); padding: 16px; border-radius: 10px; text-align: right; }
    .stat-label { font-size: 13px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
    .stat-value { font-size: 22px; font-weight: 600; margin-top: 6px; color: var(--text-light); }
    .stat-positive { color: var(--positive) !important; }
    .stat-negative { color: var(--negative) !important; }
    .monthly-stats { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; margin-bottom: 32px; }
    .month-box { background: var(--bg-card); padding: 10px 6px; border-radius: 10px; text-align: center; }
    .month-box-clickable { cursor: pointer; transition: border-color 0.2s, background 0.2s; border: 1px solid transparent; }
    .month-box-clickable:hover { background: var(--bg-header); border-color: var(--border); }
    .month-box-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; margin-bottom: 4px; }
    .month-box-value { font-size: 11px; font-weight: 500; color: var(--text-light); }
    .month-box-empty .month-box-value { color: var(--text-muted); }
    @media (max-width: 1200px) { .monthly-stats { grid-template-columns: repeat(6, 1fr); } }
    @media (max-width: 900px) { .monthly-stats { grid-template-columns: repeat(4, 1fr); } }
    table { width: 100%; border-collapse: collapse; background: var(--bg-card); border-radius: 12px; overflow: hidden; margin-bottom: 16px; }
    th, td { padding: 12px 16px; font-weight: normal; }
    th { font-weight: 600; color: var(--text-dim); font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; background: var(--bg-header); }
    .col-date, .hdr-date { width: 90px; text-align: center; }
    .col-game { width: 45px; text-align: center; }
    .col-play, .hdr-play { text-align: left; white-space: nowrap; }
    .col-line, .hdr-line { width: 90px; text-align: center; }
    .col-risk, .hdr-risk { width: 90px; text-align: center; }
    .col-result, .hdr-result { width: 90px; text-align: center; }
    .col-score, .hdr-score { width: 90px; text-align: center; }
    .col-profit, .hdr-profit { width: 90px; text-align: center; white-space: nowrap; }
    .positive { color: var(--positive); }
    .negative { color: var(--negative); }
    .bet-type { font-weight: 600; }
    .vs-separator { color: rgb(168, 168, 168); }
    .game-pill { display: inline-block; font-size: 12px; padding: 4px 8px; border-radius: 6px; font-weight: 500; }
    .col-game .game-pill { margin-left: 0; }
    .game-pill.cs2 { color: var(--cs2-text); background-color: var(--cs2-bg); }
    .game-pill.val { color: var(--val-text); background-color: var(--val-bg); }
    .extra-pill { display: inline; font-size: 12px; padding: 4px 8px; border-radius: 6px; margin-left: 8px; font-weight: 500; color: rgb(161, 161, 170); background-color: rgb(80, 80, 85); }
    .play-type-table { width: 100%; border-collapse: collapse; background: var(--bg-card); border-radius: 12px; overflow: hidden; box-shadow: none; margin-bottom: 0; }
    .play-type-table th, .play-type-table td { padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); }
    .play-type-table th { color: var(--text-muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; background: var(--bg-header); }
    .play-type-table tr:last-child td { border-bottom: none; }
    .play-type-table td:nth-child(2), .play-type-table th:nth-child(2) { text-align: center; }
    .play-type-table td:nth-child(3), .play-type-table th:nth-child(3),
    .play-type-table td:nth-child(4), .play-type-table th:nth-child(4),
    .play-type-table td:nth-child(5), .play-type-table th:nth-child(5) { text-align: right; }
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 32px; align-items: start; }
    @media (max-width: 900px) { .stats-grid { grid-template-columns: 1fr; } }
    .month-title { text-align: center; font-weight: 500; font-size: 16px; color: var(--text-light); margin: 24px 0 12px; padding: 8px 16px; background: var(--bg-header); border-radius: 8px; display: block; }
    .sidebar { width: 300px; background-color: var(--bg); padding: 20px; border-right: 1px solid var(--border); height: 100vh; position: fixed; top: 0; left: 0; overflow-y: auto; overflow-x: hidden; box-sizing: border-box; z-index: 100; }
    .sidebar ul { list-style-type: none; padding: 0; margin: 0; }
    .sidebar li { margin-bottom: 10px; padding-left: 10px; }
    .sidebar a { color: var(--text-muted); display: block; padding: 5px 0; text-decoration: none; }
    .sidebar a:hover { color: var(--text-light); }
    .sidebar a.active { color: var(--positive); background-color: rgba(74, 222, 128, 0.1); margin-left: -10px; padding-left: 10px; border-radius: 4px; }
    .search-bar { width: 100%; max-width: 300px; padding: 10px; margin-bottom: 20px; border: 1px solid var(--border); background-color: var(--bg-card); color: var(--text-muted); border-radius: 6px; box-sizing: border-box; }
    .category-header { margin-top: 20px; }
    .category-toggle { display: block; color: var(--text-light); font-weight: 600; cursor: pointer; margin-bottom: 10px; }
    .copy-box { position: fixed; top: 20px; right: 20px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 10px 14px; font-size: 18px; color: var(--text); cursor: pointer; z-index: 1000; transition: all 0.2s; user-select: none; line-height: 1; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; }
    .copy-box:hover { background: var(--bg-header); border-color: var(--positive); color: var(--positive); }
    .copy-box:active { background: var(--bg); transform: scale(0.98); }
    .chart-container { width: 100%; height: 380px; margin-bottom: 32px; background: var(--bg-card); border-radius: 12px; padding: 0; box-sizing: border-box; display: flex; flex-direction: column; }
    .chart-header { display: flex; justify-content: space-between; align-items: center; min-height: 44px; padding: 0 14px; flex-shrink: 0; }
    .chart-canvas-wrap { flex: 1; min-height: 0; padding: 0 6px 6px; }
    .chart-header-left { display: flex; align-items: center; gap: 8px; }
    .chart-header-text { font-size: 13px; font-weight: 500; color: var(--text-muted); font-family: inherit; }
    .chart-header-dot { font-size: 15px; color: rgba(255,255,255,0.4); font-family: inherit; font-weight: 400; }
    .chart-header-roi { text-transform: none; }
    .chart-header-right { display: flex; gap: 4px; }
    .chart-range-btn { background: transparent; border: 1px solid transparent; color: var(--text-muted); font-size: 12px; font-weight: 600; padding: 4px 10px; border-radius: 6px; cursor: pointer; transition: all 0.15s; font-family: inherit; }
    .chart-range-btn:hover { color: var(--text-light); background: rgba(255,255,255,0.05); }
    .chart-range-btn.active { color: var(--text-light); background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.1); }
    .mobile-menu-toggle { display: none; }
    @media (max-width: 1400px) {
      body { padding: 0; font-size: 13px; }
      .container { margin-left: 0; padding: 15px; max-width: 100%; overflow-x: hidden; }
      .sidebar { width: 100%; height: auto; position: static; border-right: none; border-bottom: 1px solid var(--border); padding: 0; }
      .sidebar .search-bar { display: none; }
      .sidebar > ul { display: none; padding: 15px; }
      .sidebar.open > ul { display: block; }
      .mobile-menu-toggle { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; background: var(--bg-card); color: var(--text-light); font-weight: 600; cursor: pointer; border: none; width: 100%; font-size: 14px; }
      .mobile-menu-toggle::after { content: "\2630"; font-size: 18px; }
      .sidebar.open .mobile-menu-toggle::after { content: "\2715"; }
      h1 { font-size: 18px !important; margin-bottom: 16px; word-wrap: break-word; }
      .stats { grid-template-columns: repeat(2, 1fr) !important; gap: 10px !important; }
      .stat-box { padding: 10px !important; }
      .stat-label { font-size: 10px !important; }
      .stat-value { font-size: 14px !important; }
      .monthly-stats { grid-template-columns: repeat(3, 1fr) !important; gap: 8px !important; }
      #extraStats { grid-template-columns: repeat(3, 1fr) !important; }
      .month-box { padding: 8px 4px !important; }
      .month-box-label { font-size: 9px !important; }
      .month-box-value { font-size: 9px !important; }
      .month-title { font-size: 12px !important; padding: 8px 6px !important; line-height: 1.4; }
      .chart-container { height: 260px !important; }
      .chart-header { padding: 8px 10px !important; }
      .chart-header-text { font-size: 10px !important; letter-spacing: 0.3px !important; }
      .chart-header-dot { font-size: 10px !important; }
      .chart-range-btn { font-size: 10px !important; padding: 3px 7px !important; }
      .chart-header-right { display: none !important; }
      table { display: table; width: 100% !important; table-layout: fixed; font-size: 11px; }
      th, td { padding: 6px 4px !important; font-size: 10px !important; overflow: hidden; text-overflow: ellipsis; }
      .col-score, .hdr-score, .col-line, .hdr-line, .col-risk, .hdr-risk { display: none !important; }
      .col-date, .hdr-date { width: 50px !important; }
      .col-game { width: 38px !important; }
      .col-play, .hdr-play { width: auto !important; }
      .col-result, .hdr-result { width: 40px !important; }
      .col-profit, .hdr-profit { width: 55px !important; white-space: nowrap !important; text-align: center !important; }
      .play-type-table .pt-risk, .play-type-table .pt-hdr-risk { display: none !important; }
      .play-type-table th:first-child, .play-type-table td:first-child { width: 18% !important; }
      .play-type-table th:nth-child(2), .play-type-table td:nth-child(2) { width: 36% !important; }
      .play-type-table td:not(:first-child), .play-type-table th:not(:first-child) { text-align: center !important; }
      canvas#profitChart { max-height: 160px !important; }
      .game-pill, .extra-pill { font-size: 9px !important; padding: 2px 5px !important; margin-left: 4px !important; }
      .play-type-table { display: table; width: 100% !important; table-layout: fixed; }
      .play-type-table th, .play-type-table td { padding: 8px 6px !important; font-size: 11px !important; }
      .stats-grid { grid-template-columns: 1fr !important; gap: 12px !important; }
      .copy-box { display: none !important; }
    }
  </style>
</head>
<body>
  <script>
    const PICKS = [
      { date: "2026-03-02", play: "Ninjas in Pyjamas PK (-110) vs. M80", score: "", game: "CS2" },
      { date: "2026-03-02", play: "Astralis PK (-125) vs. HEROIC", score: "", game: "CS2" },
      { date: "2026-03-01", play: "3DMAX PK (-110) vs. paiN", score: "1-2", game: "CS2" },
      { date: "2026-03-01", play: "FUT PK (-200) vs. M80", score: "2-1", game: "CS2" },
      { date: "2026-03-01", play: "Liquid PK (-135) vs. Passion UA", score: "0-2", game: "CS2" },
      { date: "2026-03-01", play: "Liquid PK (+130) vs. T1", score: "2-0", game: "Valorant" },
      { date: "2026-02-20", play: "Natus Vincere PK (+155) vs. MOUZ", score: "1-2", game: "CS2" },
      { date: "2026-02-18", play: "Aurora PK (-150) vs. Astralis", score: "2-0", game: "CS2" },
      { date: "2026-02-16", play: "FaZe PK (+130) vs. PARIVISION", score: "1-2", game: "CS2" },
      { date: "2026-02-15", play: "The MongolZ +1.5 (+135) vs. Vitality", score: "1-2", game: "CS2" },
      { date: "2026-02-15", play: "3DMAX PK (+125) vs. Astralis", score: "0-2", game: "CS2" },
      { date: "2026-02-14", play: "PARIVISION PK (+155) vs. MOUZ", score: "1-2", game: "CS2" },
      { date: "2026-02-14", play: "B8 +1.5 (+125) vs. FURIA", score: "0-2", game: "CS2" },
      { date: "2026-02-08", play: "FURIA +1.5 (-110) vs. Vitality", score: "1-3", game: "CS2" },
      { date: "2026-02-06", play: "Ninjas in Pyjamas PK (-125) vs. Gentle Mates", score: "2-1", game: "CS2", extra: true },
      { date: "2026-02-02", play: "FURIA PK (-130) vs. Natus Vincere", score: "2-1", game: "CS2" },
      { date: "2026-02-02", play: "NRG +1.5 (+225) vs. Falcons", score: "1-2", game: "CS2" },
      { date: "2026-02-02", play: "MOUZ PK (-175) vs. Aurora", score: "0-2", game: "CS2" },
      { date: "2026-02-02", play: "FaZe PK (-175) vs. BC.Game", score: "2-1", game: "CS2" },
      { date: "2026-02-01", play: "FUT PK (+150) vs. G2", score: "1-2", game: "CS2" },
      { date: "2026-02-01", play: "Astralis +1.5 (-125) vs. PARIVISION", score: "2-1", game: "CS2" },
      { date: "2026-02-01", play: "MOUZ -1.5 (-140) vs. NRG", score: "2-0", game: "CS2" },
      { date: "2026-02-01", play: "Aurora +1.5 (-140) vs. Falcons", score: "2-1", game: "CS2" },
      { date: "2026-01-31", play: "3DMAX PK (+160) vs. FaZe", score: "2-0", game: "CS2" },
      { date: "2026-01-30", play: "FUT PK (-105) vs. Liquid", score: "2-0", game: "CS2" },
      { date: "2026-01-29", play: "Liquid PK (+180) vs. G2", score: "1-2", game: "CS2" },
      { date: "2026-01-28", play: "3DMAX PK (+120) vs. FUT", score: "2-1", game: "CS2" },
      { date: "2026-01-28", play: "Liquid PK (+110) vs. NiP", score: "2-0", game: "CS2" },
      { date: "2026-01-28", play: "Liquid PK (-105) vs. NiP", score: "2-0", game: "CS2" },
      { date: "2026-01-23", play: "PARIVISION +1.5 (-110) vs. Spirit", score: "2-1", game: "CS2" },
      { date: "2026-01-22", play: "FURIA -1.5 (-110) vs. HEROIC", score: "2-1", game: "CS2" },
      { date: "2026-01-21", play: "HOTU PK (+150) vs. Gentle Mates", score: "2-0", game: "CS2", extra: true },
      { date: "2026-01-18", play: "Astralis PK (+140) vs. PARIVISION", score: "0-2", game: "CS2" },
      { date: "2026-01-17", play: "HEROIC PK (+125) vs. paiN", score: "2-0", game: "CS2" },
      { date: "2026-01-15", play: "Liquid PK (+115) vs. Ninjas in Pyjamas", score: "2-1", game: "CS2" },
      { date: "2026-01-14", play: "Monte +1.5 (+150) vs. Natus Vincere", score: "2-1", game: "CS2" },
      { date: "2026-01-14", play: "GamerLegion PK (+105) vs. Passion UA", score: "2-1", game: "CS2" },
      { date: "2026-01-13", play: "OG PK (+180) vs. FUT", score: "0-2", game: "CS2" },
    ];
  </script>

  <aside class="sidebar">
    <button class="mobile-menu-toggle" onclick="this.parentElement.classList.toggle('open')">Menu</button>
    <input type="text" class="search-bar" placeholder="Search">
    <ul>
      <li><a href="../index">Home</a></li>
      <li><a href="https://x.com/causticarrow">&#120143; (Twitter)</a></li>
      <li><a href="https://discord.gg/hammer">Discord</a></li>
      <li class="category-header">
        <span class="category-toggle">Results</span>
        <ul class="category-content" id="results-list"></ul>
      </li>
    </ul>
  </aside>
  <div class="copy-box" id="copyBox">&#128203;</div>
  <div class="container">
    <h1>@causticarrow // 2026 esports</h1>
    <div class="stats">
      <div class="stat-box"><div class="stat-label">Record</div><div class="stat-value" id="totalPlays">0</div></div>
      <div class="stat-box"><div class="stat-label">Net Risk</div><div class="stat-value" id="netRisk">0</div></div>
      <div class="stat-box"><div class="stat-label">Net Profit</div><div class="stat-value" id="netProfit">+0.0</div></div>
      <div class="stat-box"><div class="stat-label">ROI</div><div class="stat-value" id="roi">+0.0%</div></div>
    </div>
    <div class="monthly-stats" id="extraStats" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 32px;"></div>
    <div class="monthly-stats" id="monthlyStats"></div>
    <div class="chart-container">
      <div class="chart-header">
        <div class="chart-header-left">
          <span class="chart-header-text" id="chartPeriodLabel">YTD</span>
          <span class="chart-header-dot">·</span>
          <span class="chart-header-text">CAUSTICARROW</span>
          <span class="chart-header-dot">·</span>
          <span class="chart-header-text" id="chartProfitValue">+0.0u</span>
          <span class="chart-header-text chart-header-roi" id="chartRoiValue">(0%)</span>
        </div>
        <div class="chart-header-right">
          <button class="chart-range-btn" data-range="1D">1D</button>
          <button class="chart-range-btn" data-range="1W">1W</button>
          <button class="chart-range-btn" data-range="1M">1M</button>
          <button class="chart-range-btn" data-range="3M">3M</button>
          <button class="chart-range-btn" data-range="6M">6M</button>
          <button class="chart-range-btn" data-range="9M">9M</button>
          <button class="chart-range-btn" data-range="YTD">YTD</button>
          <button class="chart-range-btn active" data-range="ALL">ALL</button>
        </div>
      </div>
      <div class="chart-canvas-wrap">
        <canvas id="profitChart"></canvas>
      </div>
    </div>
    <div class="stats-grid" id="playTypeSection"></div>
    <div id="tablesContainer"></div>
  </div>

  <script>
    const isMobile = () => window.innerWidth <= 768;
    const isCompact = () => window.innerWidth <= 1400;
    const parseDate = s => { const [y, m, d] = s.split("-").map(Number); return new Date(y, m - 1, d); };
    const formatDate = s => { const [y, m, d] = s.split("-"); return `${+m}/${+d}/${y.slice(-2)}`; };
    const stripZeros = s => String(s).includes(".") ? String(s).replace(/\.?0+$/, "") : String(s);

    const MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    const MONTH_LONG = { January: "Jan", February: "Feb", March: "Mar", April: "Apr", May: "May", June: "Jun", July: "Jul", August: "Aug", September: "Sep", October: "Oct", November: "Nov", December: "Dec" };
    const shortenMonth = m => isMobile() ? m.replace(/^(\w+)/, x => MONTH_LONG[x] || x) : m;

    const TEAM_ABBR = {
      "Shopify Rebellion": "SR", "Nongshim RedForce": "NS", "Ninjas in Pyjamas": "NIP",
      "FunPlus Phoenix": "FPX", "Rex Regum Qeon": "RRQ", "Natus Vincere": "NAVI",
      "Dragon Ranger": "DRG", "Evil Geniuses": "EG", "100 Thieves": "100T",
      "Eternal Fire": "EF", "Gentle Mates": "M8", "Karmine Corp": "KC",
      "Inner Circle": "IC", "The MongolZ": "MGLZ", "Lynn Vision": "LV",
      "RED Canids": "RED", "Rare Atom": "RA", "Passion UA": "P.UA",
      "Paper Rex": "PRX", "All Gamers": "AG", "Xi Lai": "XLG",
      "BC.Game": "BC.G", GamerLegion: "GL", PARIVISION: "PV", EYEBALLERS: "EB",
      Heretics: "TH", Leviatan: "LEV", Bilibili: "BLG", Vitality: "VIT",
      Falcons: "FLC", Nemesis: "NMSS", BetBoom: "BB", Imperial: "IMP",
      ELEVATE: "ELV", EDward: "EDG", Cloud9: "C9", HEROIC: "HERO",
      Aurora: "AUR", Spirit: "TS", Liquid: "TL", VARREL: "VL",
      GIANTX: "GX", Legacy: "LGCY", FURIA: "FUR", TYLOO: "TYL",
      "3DMAX": "3D", Dplus: "DK", fnatic: "FNC", Astralis: "AST",
    };

    const fmtNum = n => stripZeros(n.toFixed(2));
    const fmtWinPct = n => isMobile() ? Math.round(n).toString() : stripZeros(n.toFixed(2));
    const fmtUnits = n => n === 0 ? "0.0" : (n > 0 ? "+" : "-") + (Math.abs(n - Math.round(n)) < 0.001 ? Math.abs(n).toFixed(1) : stripZeros(Math.abs(n).toFixed(2)));
    const fmtUnitsHdr = n => n === 0 ? "0.0" : (isMobile() ? (n > 0 ? "+" : "-") + Math.abs(n).toFixed(1) : fmtUnits(n));
    const fmtSigned = n => n === 0 ? "0" : (n > 0 ? "+" : "-") + stripZeros(Math.abs(n).toFixed(2));
    const fmtSignedPct = n => n === 0 ? "0%" : fmtSigned(n) + "%";
    const fmtROI = n => n === 0 ? "0%" : (isMobile() ? (Math.round(n) > 0 ? "+" : "") + Math.round(n) + "%" : fmtSignedPct(n));
    const getValueClass = n => n === 0 ? "" : n > 0 ? "positive" : "negative";
    const getStatClass = n => n === 0 ? "" : n > 0 ? "stat-positive" : "stat-negative";

    function calcRisk(odds, isExtra = false) {
      const a = parseInt(odds);
      const riskFor1u = a > 0 ? 100 / a : -a / 100;
      return isExtra ? riskFor1u * 0.5 : riskFor1u;
    }

    function calcUnits(odds, result, isExtra = false) {
      if (result === "Pending") return 0;
      return result === "W" ? (isExtra ? 0.5 : 1.0) : -calcRisk(odds, isExtra);
    }

    function calcAdjustedRecord(w, l, profit, globalAvgRisked) {
      const total = w + l;
      if (total === 0 || globalAvgRisked === 0) return { adjW: 0, adjL: 0 };
      const adjW = (total + profit / globalAvgRisked) / 2;
      return { adjW, adjL: Math.max(total - adjW, 0) };
    }
    function detectResult(play, score) {
      if (!score || score === "" || score === undefined) return "Pending";
      const scoreParts = score.split("-").map(Number);
      if (scoreParts.length < 2 || isNaN(scoreParts[0]) || isNaN(scoreParts[1])) return "Pending";
      let team1Score = scoreParts[0];
      const team2Score = scoreParts[1];
      const handicapMatch = play.match(/\s([+-]\d+\.?\d*)\s+\(/);
      if (handicapMatch && play.indexOf('PK') === -1) {
        team1Score += parseFloat(handicapMatch[1]);
      }
      if (team1Score > team2Score) return "W";
      if (team1Score < team2Score) return "L";
      return "P";
    }
    const ODDS_RE = /\(([-+]?\d+)\)/;
    PICKS.forEach(p => {
      p.result = detectResult(p.play, p.score);
      const m = p.play.match(ODDS_RE);
      if (m) {
        p._odds = m[1];
        p._isExtra = p.extra === true;
        p._isPending = p.result === "Pending";
        p._risk = calcRisk(p._odds, p._isExtra);
        p._units = calcUnits(p._odds, p.result, p._isExtra);
      }
    });

    window.addEventListener("load", () => {
      const container = document.getElementById("tablesContainer");
      const mobile = isMobile();
      let wins = 0, losses = 0, totalRisk = 0, totalUnits = 0;
      let totalDecimalOdds = 0, oddsCount = 0;
      const monthlyData = {};
      const gameStats = {};
      const emptyBucket = () => ({ wins: 0, losses: 0, pushes: 0, units: 0, risk: 0 });
      const playTypes = { "Pick'ems": emptyBucket(), Handicaps: emptyBucket(), Totals: emptyBucket(), Extras: emptyBucket(), Favourites: emptyBucket(), Dogs: emptyBucket(), Overs: emptyBucket(), Unders: emptyBucket() };

      PICKS.forEach(p => {
        if (!p._odds || p._isPending) return;
        totalUnits += p._units;
        totalRisk += p._risk;
        p.result === "W" ? wins++ : losses++;

        const a = parseInt(p._odds);
        totalDecimalOdds += a < 0 ? 1 + (100 / Math.abs(a)) : 1 + (a / 100);
        oddsCount++;

        const mo = parseDate(p.date).getMonth();
        if (!monthlyData[mo]) monthlyData[mo] = { risk: 0, units: 0 };
        monthlyData[mo].risk += p._risk;
        monthlyData[mo].units += p._units;

        if (p.game) {
          if (!gameStats[p.game]) gameStats[p.game] = emptyBucket();
          gameStats[p.game].risk += p._risk;
          gameStats[p.game].units += p._units;
          if (p.result === "W") gameStats[p.game].wins++;
          else if (p.result === "P") gameStats[p.game].pushes++;
          else gameStats[p.game].losses++;
        }

        const oddsNum = a;
        const isSide = / PK /i.test(p.play);
        const handicapMatch = p.play.match(/[+-]\d+\.5/);
        const isHandicap = !!handicapMatch;
        const isOver = / Over /i.test(p.play);
        const isUnder = / Under /i.test(p.play);
        const isTotal = isOver || isUnder;
        const addTo = type => {
          playTypes[type].risk += p._risk;
          playTypes[type].units += p._units;
          if (p.result === "W") playTypes[type].wins++;
          else if (p.result === "P") playTypes[type].pushes++;
          else playTypes[type].losses++;
        };
        if (p._isExtra) { addTo("Extras"); }
        else if (isSide) { addTo("Pick'ems"); }
        else if (isHandicap) { addTo("Handicaps"); }
        else if (isTotal) { addTo("Totals"); }
        if (!p._isExtra) {
          if (isHandicap) { parseFloat(handicapMatch[0]) < 0 ? addTo("Favourites") : addTo("Dogs"); }
          else if (!isTotal) { oddsNum < 0 ? addTo("Favourites") : addTo("Dogs"); }
          if (isOver) addTo("Overs");
          if (isUnder) addTo("Unders");
        }
      });

      const totalPlays = wins + losses;
      const globalAvgRisked = totalPlays > 0 ? totalRisk / totalPlays : 0;
      const chartDates = ["Start"], chartCumulativeUnits = [0];
      const gameChartData = {};
      const gameFirstIndex = {};
      let cumUnits = 0, lastMonth = -1;
      const monthBoundaries = [];
      const gameCumUnits = {};
      const sortedForChart = [...PICKS].filter(p => p._odds).sort((a, b) => {
        const d = parseDate(a.date) - parseDate(b.date);
        return d !== 0 ? d : a.play.localeCompare(b.play);
      });
      sortedForChart.forEach((pick, idx) => {
        cumUnits += pick._units;
        chartDates.push(pick.date);
        chartCumulativeUnits.push(cumUnits);
        const currentIdx = chartDates.length - 1;
        if (pick.game) {
          if (!(pick.game in gameCumUnits)) {
            gameCumUnits[pick.game] = 0;
            gameFirstIndex[pick.game] = currentIdx;
          }
          gameCumUnits[pick.game] += pick._units;
        }
        for (const g of Object.keys(gameCumUnits)) {
          if (!gameChartData[g]) gameChartData[g] = [];
          while (gameChartData[g].length < currentIdx) {
            if (gameChartData[g].length < gameFirstIndex[g] - 1) {
              gameChartData[g].push(null);
            } else if (gameChartData[g].length === gameFirstIndex[g] - 1) {
              gameChartData[g].push(0);
            } else {
              gameChartData[g].push(gameChartData[g][gameChartData[g].length - 1]);
            }
          }
          gameChartData[g].push(gameCumUnits[g]);
        }

        const m = parseDate(pick.date).getMonth();
        if (m !== lastMonth) {
          monthBoundaries.push({ index: chartDates.length - 1, month: MONTH_NAMES[m] });
          lastMonth = m;
        }
      });
      for (const g of Object.keys(gameChartData)) {
        while (gameChartData[g].length < chartDates.length) {
          gameChartData[g].push(gameChartData[g][gameChartData[g].length - 1]);
        }
      }
      const sorted = [...PICKS].sort((a, b) => {
        const d = parseDate(b.date) - parseDate(a.date);
        return d !== 0 ? d : b.play.localeCompare(a.play);
      });
      const grouped = {};
      sorted.forEach(p => {
        const d = parseDate(p.date);
        const key = `${d.toLocaleString("default", { month: "long" })} ${d.getFullYear()}`;
        (grouped[key] ||= []).push(p);
      });

      function parsePlayLine(play) {
        const oddsMatch = play.match(ODDS_RE);
        const line = oddsMatch ? oddsMatch[1] : "";
        const cleanPlay = play.replace(/\s*\([-+]?\d+\)\s*/, " ").replace(/\s+/g, " ").trim();
        return { cleanPlay, line };
      }
      Object.keys(grouped).sort((a, b) => parseDate(grouped[b][0].date) - parseDate(grouped[a][0].date)).forEach(monthName => {
        const monthPicks = grouped[monthName];
        let mWins = 0, mLosses = 0, mRisk = 0, mUnits = 0;

        const table = document.createElement("table");
        table.innerHTML = `<thead><tr><th class="hdr-date">Date</th><th class="col-game"></th><th class="hdr-play">Play</th><th class="hdr-line">Line</th><th class="hdr-risk">Risk</th><th class="hdr-score">Score</th><th class="hdr-result">Result</th><th class="hdr-profit">Profit</th></tr></thead><tbody></tbody>`;
        const tbody = table.querySelector("tbody");

        monthPicks.forEach(pick => {
          if (!pick._odds) return;
          if (!pick._isPending) {
            mUnits += pick._units;
            mRisk += pick._risk;
            pick.result === "W" ? mWins++ : mLosses++;
          }

          const { cleanPlay, line } = parsePlayLine(pick.play);
          let fp = cleanPlay.replace(/^\d+\s+/, "").replace(/<\/?span[^>]*>/g, "");
          if (mobile) {
            fp = fp.replace(/\s+vs\.\s+[^(]+(?=\s*$)/g, "");
            for (const [full, abbr] of Object.entries(TEAM_ABBR)) fp = fp.replace(new RegExp(full, "g"), abbr);
          } else if (isCompact()) {
            for (const [full, abbr] of Object.entries(TEAM_ABBR)) fp = fp.replace(new RegExp(full, "g"), abbr);
            fp = fp.replace(/\s+vs\.\s+/g, ' <span class="vs-separator">vs.</span> ');
          } else {
            fp = fp.replace(/\s+vs\.\s+/g, ' <span class="vs-separator">vs.</span> ');
          }
          fp = fp.replace(/\b(PK)\b/g, '<span class="bet-type">$1</span>')
                 .replace(/(Over|Under)\s+(\d+\.?\d*)/g, '<span class="bet-type">$1 $2</span>')
                 .replace(/(?<![">a-zA-Z0-9])([+-]\d+\.?\d*)(?![^<]*<\/span>)/g, '<span class="bet-type">$1</span>');
          if (pick._isExtra) fp += ` <span class="extra-pill">Extra</span>`;

          const gamePillClass = pick.game === 'Valorant' ? 'val' : pick.game.toLowerCase().replace(" ", "");
          const gamePillLabel = pick.game === 'Valorant' ? 'VAL' : pick.game;
          const gameCell = pick.game ? `<span class="game-pill ${gamePillClass}">${gamePillLabel}</span>` : "";
          const lineDisplay = line ? (line.startsWith("+") || line.startsWith("-") ? line : (parseInt(line) > 0 ? "+" + line : line)) : "";
          const row = document.createElement("tr");
          row.innerHTML = `<td class="col-date">${formatDate(pick.date)}</td><td class="col-game">${gameCell}</td><td class="col-play"></td><td class="col-line">${lineDisplay}</td><td class="col-risk">${fmtNum(pick._risk)}u</td><td class="col-score">${pick.score}</td><td class="col-result ${pick._isPending ? "" : pick.result === "W" ? "positive" : "negative"}">${pick._isPending ? "Pending" : pick.result === "W" ? "Win" : "Loss"}</td><td class="col-profit ${pick._isPending ? "" : getValueClass(pick._units)}">${pick._isPending ? "" : fmtUnits(pick._units) + "u"}</td>`;
          row.querySelector(".col-play").innerHTML = fp;
          tbody.appendChild(row);
        });

        container.appendChild(table);
        const mRoi = mRisk ? (mUnits / mRisk) * 100 : 0;
        const { adjW: mAdjW, adjL: mAdjL } = calcAdjustedRecord(mWins, mLosses, mUnits, globalAvgRisked);
        const mAdjWinPct = (mAdjW + mAdjL) > 0 ? (mAdjW / (mAdjW + mAdjL)) * 100 : 0;
        const header = document.createElement("h2");
        header.className = "month-title";
        header.id = `month-${new Date(Date.parse(monthName.split(" ")[0] + " 1, 2000")).getMonth()}`;
        header.innerHTML = `${shortenMonth(monthName)}: ${Math.round(mAdjW)}-${Math.round(mAdjL)} (${fmtWinPct(mAdjWinPct)}%), <span class="${getValueClass(mUnits)}">${fmtUnitsHdr(mUnits)}u</span>, <span class="${getValueClass(mRoi)}">${fmtROI(mRoi).replace(/^\+/, "")} ROI</span>`;
        container.insertBefore(header, table);
      });
      const roi = totalRisk ? (totalUnits / totalRisk) * 100 : 0;
      const { adjW: topAdjW, adjL: topAdjL } = calcAdjustedRecord(wins, losses, totalUnits, globalAvgRisked);
      const topAdjWinPct = (topAdjW + topAdjL) > 0 ? (topAdjW / (topAdjW + topAdjL)) * 100 : 0;
      document.getElementById("totalPlays").textContent = `${Math.round(topAdjW)}-${Math.round(topAdjL)} (${fmtNum(topAdjWinPct)}%)`;
      document.getElementById("netRisk").textContent = fmtNum(totalRisk) + "u";
      const profitEl = document.getElementById("netProfit");
      profitEl.textContent = fmtSigned(totalUnits) + "u";
      profitEl.className = `stat-value ${getStatClass(totalUnits)}`;
      const roiEl = document.getElementById("roi");
      roiEl.textContent = fmtSignedPct(roi).replace(/^\+/, "");
      roiEl.className = `stat-value ${getStatClass(roi)}`;
      {
        const avgDec = oddsCount > 0 ? totalDecimalOdds / oddsCount : 0;
        const avgAmericanRaw = avgDec >= 2 ? (avgDec - 1) * 100 : -100 / (avgDec - 1);
        const avgProb = avgDec > 0 ? (1 / avgDec) * 100 : 0;
        const fmt1d = n => { const s = Math.abs(n).toFixed(1); return s.endsWith(".0") ? Math.round(Math.abs(n)).toString() : s; };
        const fmtPct1d = p => { const s = p.toFixed(1); return s.endsWith(".0") ? Math.round(p).toString() : s; };
        const avgOddsFmt = (avgAmericanRaw >= 0 ? "+" : "-") + fmt1d(avgAmericanRaw) + " (" + fmtPct1d(avgProb) + "%)";

        const avgRisk = totalPlays > 0 ? totalRisk / totalPlays : 0;
        const avgRiskFmt = fmtNum(avgRisk) + "u";

        const extraStatsEl = document.getElementById("extraStats");
        [
          { label: mobile ? "n" : "Total Plays", value: totalPlays.toString() },
          { label: mobile ? "Avg Size" : "Average Unit Size", value: avgRiskFmt },
          { label: mobile ? "Avg Odds" : "Average Odds", value: avgOddsFmt },
        ].forEach(item => {
          const box = document.createElement("div");
          box.className = "month-box";
          box.innerHTML = `<div class="month-box-label">${item.label}</div><div class="month-box-value">${item.value}</div>`;
          extraStatsEl.appendChild(box);
        });
      }
      const MONTHS = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
      const monthlyStatsEl = document.getElementById("monthlyStats");
      MONTHS.forEach((name, i) => {
        const box = document.createElement("div");
        const data = monthlyData[i];
        if (data && data.risk > 0) {
          const mRoi = (data.units / data.risk) * 100;
          box.className = "month-box month-box-clickable";
          box.innerHTML = `<div class="month-box-label">${name}</div><div class="month-box-value"><span class="${getValueClass(data.units)}">${fmtSigned(data.units)}u</span>, <span class="${getValueClass(mRoi)}">${fmtSignedPct(mRoi).replace(/^\+/, "")}</span></div>`;
          box.addEventListener("click", () => {
            if (mobile) return;
            const target = document.getElementById(`month-${i}`);
            if (target) target.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        } else {
          box.className = "month-box month-box-empty";
          box.innerHTML = `<div class="month-box-label">${name}</div><div class="month-box-value"></div>`;
        }
        monthlyStatsEl.appendChild(box);
      });
      const playTypeSectionEl = document.getElementById("playTypeSection");
      const gameColors = { 'CS2': 'rgb(96, 165, 250)', 'Valorant': 'rgb(251, 146, 60)' };

      function buildSummaryRow(name, d, nameStyle) {
        const { adjW, adjL } = calcAdjustedRecord(d.wins, d.losses, d.units, globalAvgRisked);
        const winPctVal = (adjW + adjL) > 0 ? (adjW / (adjW + adjL)) * 100 : 0;
        const record = d.pushes > 0 ? `${Math.round(adjW)}-${Math.round(adjL)}-${d.pushes}` : `${Math.round(adjW)}-${Math.round(adjL)}`;
        const r = d.risk ? (d.units / d.risk * 100) : 0;
        const row = document.createElement("tr");
        row.innerHTML = `<td${nameStyle ? ' style="' + nameStyle + '"' : ''}>${name}</td><td>${record} (${fmtNum(winPctVal)}%)</td><td class="pt-risk">${fmtNum(d.risk)}u</td><td class="${getValueClass(d.units)}">${fmtSigned(d.units)}u</td><td class="${getValueClass(r)}">${fmtSignedPct(r).replace(/^\+/, "")}</td>`;
        return row;
      }

      const activeGames = Object.entries(gameStats).filter(([_, d]) => d.wins + d.losses + d.pushes > 0).sort((a, b) => a[0].localeCompare(b[0]));
      if (activeGames.length > 0) {
        const gameTable = document.createElement("table");
        gameTable.className = "play-type-table";
        const profitLabel = mobile ? "Profit" : "Net Profit";
        gameTable.innerHTML = `<thead><tr><th>Game</th><th>Record</th><th class="pt-hdr-risk">Net Risk</th><th>${profitLabel}</th><th>ROI</th></tr></thead><tbody></tbody>`;
        const tbody = gameTable.querySelector("tbody");
        activeGames.forEach(([name, d]) => tbody.appendChild(buildSummaryRow(name, d, `color: ${gameColors[name] || 'var(--text-light)'}`)));
        playTypeSectionEl.appendChild(gameTable);
      }

      const typeOrder = ["Pick'ems", "Handicaps", "Totals", "Extras", "Favourites", "Dogs", "Overs", "Unders"];
      const activeTypes = typeOrder.filter(name => { const d = playTypes[name]; return d.wins + d.losses + d.pushes > 0; });
      if (activeTypes.length > 0) {
        const table = document.createElement("table");
        table.className = "play-type-table";
        const ptProfitLabel = mobile ? "Profit" : "Net Profit";
        const ptTypeLabel = mobile ? "Type" : "Play Type";
        table.innerHTML = `<thead><tr><th>${ptTypeLabel}</th><th>Record</th><th class="pt-hdr-risk">Net Risk</th><th>${ptProfitLabel}</th><th>ROI</th></tr></thead><tbody></tbody>`;
        const tbody = table.querySelector("tbody");
        activeTypes.forEach(name => tbody.appendChild(buildSummaryRow(name, playTypes[name], null)));
        playTypeSectionEl.appendChild(table);
      }
      const copyText = `ytd record: ${Math.round(topAdjW)}-${Math.round(topAdjL)}, ${fmtSigned(totalUnits)}u // [archive](https://causticarrow.com/results/esports-2026)`;
      const copyBox = document.getElementById("copyBox");
      copyBox.onclick = () => {
        navigator.clipboard.writeText(copyText).then(() => {
          copyBox.textContent = "\u2713";
          copyBox.style.borderColor = "#4ade80";
          copyBox.style.color = "#4ade80";
          setTimeout(() => { copyBox.textContent = "\uD83D\uDCCB"; copyBox.style.borderColor = "#2a2a2a"; copyBox.style.color = "#e6e6e6"; }, 1000);
        });
      };
      const ctx = document.getElementById("profitChart").getContext("2d");

      const createZeroCrossingGradient = (chartCtx, y0, y1, yScale, isBackground = false) => {
        const pixel0 = yScale.getPixelForValue(y0);
        const pixel1 = yScale.getPixelForValue(y1);
        const gradient = chartCtx.createLinearGradient(0, pixel0, 0, pixel1);
        const red = isBackground ? "rgba(248, 113, 113, 0.08)" : "#f87171";
        const green = isBackground ? "rgba(74, 222, 128, 0.08)" : "#4ade80";
        if (y0 < 0 && y1 >= 0) {
          const r = Math.abs(y0) / (Math.abs(y0) + y1);
          gradient.addColorStop(0, red); gradient.addColorStop(r, red);
          gradient.addColorStop(r, green); gradient.addColorStop(1, green);
        } else if (y0 >= 0 && y1 < 0) {
          const r = y0 / (y0 + Math.abs(y1));
          gradient.addColorStop(0, green); gradient.addColorStop(r, green);
          gradient.addColorStop(r, red); gradient.addColorStop(1, red);
        }
        return gradient;
      };
      const fullChartDates = [...chartDates];
      const fullChartCumulativeUnits = [...chartCumulativeUnits];
      const fullGameChartData = {};
      for (const [g, d] of Object.entries(gameChartData)) fullGameChartData[g] = [...d];
      const fullMonthBoundaries = [...monthBoundaries];
      let filteredDates = fullChartDates;
      let filteredUnits = fullChartCumulativeUnits;
      let filteredGameData = fullGameChartData;
      let filteredMonthBoundaries = fullMonthBoundaries;
      let currentRange = 'ALL';

      function getFilteredData(range) {
        if (range === 'ALL') {
          return { dates: fullChartDates, units: fullChartCumulativeUnits, games: fullGameChartData, months: fullMonthBoundaries, rangeUnits: totalUnits, rangeRisk: totalRisk };
        }
        const now = new Date();
        let cutoff;
        if (range === '1D') { cutoff = new Date(now); cutoff.setDate(cutoff.getDate() - 1); }
        else if (range === '1W') { cutoff = new Date(now); cutoff.setDate(cutoff.getDate() - 7); }
        else if (range === '1M') { cutoff = new Date(now); cutoff.setMonth(cutoff.getMonth() - 1); }
        else if (range === '3M') { cutoff = new Date(now); cutoff.setMonth(cutoff.getMonth() - 3); }
        else if (range === '6M') { cutoff = new Date(now); cutoff.setMonth(cutoff.getMonth() - 6); }
        else if (range === '9M') { cutoff = new Date(now); cutoff.setMonth(cutoff.getMonth() - 9); }
        else if (range === 'YTD') { cutoff = new Date(now.getFullYear(), 0, 1); }
        let startIdx = 0;
        for (let i = 1; i < fullChartDates.length; i++) {
          if (parseDate(fullChartDates[i]) >= cutoff) {
            startIdx = Math.max(0, i - 1);
            break;
          }
        }

        const baselineUnits = fullChartCumulativeUnits[startIdx];
        const dates = fullChartDates.slice(startIdx);
        const units = fullChartCumulativeUnits.slice(startIdx).map(v => v - baselineUnits);

        const games = {};
        for (const [g, d] of Object.entries(fullGameChartData)) {
          const baseGame = d[startIdx] || 0;
          games[g] = d.slice(startIdx).map(v => v === null ? null : v - baseGame);
        }

        const months = fullMonthBoundaries
          .filter(b => b.index >= startIdx)
          .map(b => ({ ...b, index: b.index - startIdx }));
        let rangeUnits = 0, rangeRisk = 0;
        sortedForChart.forEach(p => {
          if (p._isPending || !p._odds) return;
          if (parseDate(p.date) >= cutoff) {
            rangeUnits += p._units;
            rangeRisk += p._risk;
          }
        });

        return { dates, units, games, months, rangeUnits, rangeRisk };
      }

      function updateChartHeader(rangeUnits, rangeRisk, range) {
        const profitEl = document.getElementById('chartProfitValue');
        const roiEl = document.getElementById('chartRoiValue');
        const periodEl = document.getElementById('chartPeriodLabel');
        profitEl.textContent = fmtUnits(rangeUnits) + 'u';
        profitEl.style.color = rangeUnits >= 0 ? 'var(--positive)' : 'var(--negative)';
        const roiVal = rangeRisk > 0 ? (rangeUnits / rangeRisk) * 100 : 0;
        roiEl.textContent = '(' + fmtSignedPct(roiVal).replace(/^\+/, '') + ')';
        roiEl.style.color = roiVal >= 0 ? 'var(--positive)' : 'var(--negative)';
        const periodLabels = { '1D': '1D', '1W': '1W', '1M': '1M', '3M': '3M', '6M': '6M', '9M': '9M', 'YTD': 'YTD', 'ALL': 'ALL' };
        periodEl.textContent = periodLabels[range] || 'YTD';
      }

      let profitChart = null;

      function buildChart(range) {
        currentRange = range;
        const { dates, units, games, months, rangeUnits, rangeRisk } = getFilteredData(range);
        filteredDates = dates;
        filteredUnits = units;
        filteredGameData = games;
        filteredMonthBoundaries = months;

        updateChartHeader(rangeUnits, rangeRisk, range);

        const tp = units.length;
        const dr = tp <= 30 ? 3 : tp <= 60 ? 2 : tp <= 120 ? 1.5 : 1;
        const dh = dr + 2;

        if (profitChart) profitChart.destroy();

        const lineGlowPlugin = {
          id: 'lineGlow',
          beforeDatasetDraw(chart, args) {
            if (args.index !== 0) return;
            chart.ctx.save();
            chart.ctx.shadowColor = 'rgba(74, 222, 128, 0.3)';
            chart.ctx.shadowBlur = 12;
          },
          afterDatasetDraw(chart, args) {
            if (args.index !== 0) return;
            chart.ctx.restore();
          }
        };

        const zeroLinePlugin = {
          id: 'zeroLine',
          beforeDraw(chart) {
            const { ctx: c, chartArea, scales: { y } } = chart;
            if (!chartArea || y.min >= 0 || y.max <= 0) return;
            const yPos = y.getPixelForValue(0);
            c.save(); c.strokeStyle = 'rgba(255, 255, 255, 0.1)'; c.lineWidth = 1;
            c.beginPath(); c.moveTo(chartArea.left, yPos); c.lineTo(chartArea.right, yPos); c.stroke(); c.restore();
          }
        };

        const monthLinePlugin = {
          id: 'monthLines',
          afterDraw(chart) {
            const { ctx: c, chartArea, scales: { x } } = chart;
            if (!chartArea) return;
            filteredMonthBoundaries.forEach(b => {
              const xPos = x.getPixelForValue(b.index);
              if (xPos < chartArea.left || xPos > chartArea.right) return;
              c.save(); c.strokeStyle = 'rgba(255, 255, 255, 0.06)'; c.lineWidth = 1; c.setLineDash([3, 5]);
              c.beginPath(); c.moveTo(xPos, chartArea.top); c.lineTo(xPos, chartArea.bottom); c.stroke(); c.setLineDash([]);
              c.fillStyle = 'rgba(255, 255, 255, 0.25)'; c.font = '10px Roboto, system-ui, sans-serif'; c.textAlign = 'center';
              c.fillText(b.month, xPos, chartArea.top - 6); c.restore();
            });
          }
        };

        const currentLinePlugin = {
          id: 'currentLine',
          beforeDraw(chart) {
            const { ctx: c, chartArea, scales: { y } } = chart;
            if (!chartArea) return;
            const lastVal = filteredUnits[filteredUnits.length - 1];
            if (lastVal === undefined || lastVal === 0) return;
            const yPos = y.getPixelForValue(lastVal);
            c.save();
            c.strokeStyle = lastVal >= 0 ? 'rgba(74, 222, 128, 0.35)' : 'rgba(248, 113, 113, 0.35)';
            c.lineWidth = 1; c.setLineDash([4, 4]);
            c.beginPath(); c.moveTo(chartArea.left, yPos); c.lineTo(chartArea.right, yPos); c.stroke();
            c.setLineDash([]); c.restore();
          }
        };

        const endLabelPlugin = {
          id: 'endLabel',
          afterDraw(chart) {
            const { ctx: c, chartArea, scales: { y }, width } = chart;
            if (!chartArea) return;
            const lastVal = filteredUnits[filteredUnits.length - 1];
            if (lastVal === undefined) return;
            const yPos = y.getPixelForValue(lastVal);
            const isPos = lastVal >= 0;
            const color = isPos ? '#4ade80' : '#f87171';
            const bgCol = isPos ? 'rgba(74, 222, 128, 0.15)' : 'rgba(248, 113, 113, 0.15)';
            const bdCol = isPos ? 'rgba(74, 222, 128, 0.5)' : 'rgba(248, 113, 113, 0.5)';
            const text = fmtUnits(lastVal) + 'u';
            c.save(); c.font = 'bold 11px Roboto, system-ui, sans-serif';
            const tw = c.measureText(text).width;
            const pX = 8, pH = 18, pW = tw + pX * 2;
            const pillX = width - pW - 4, pillY = yPos - pH / 2;
            c.fillStyle = bgCol; c.beginPath(); c.roundRect(pillX, pillY, pW, pH, 4); c.fill();
            c.strokeStyle = bdCol; c.lineWidth = 1; c.beginPath(); c.roundRect(pillX, pillY, pW, pH, 4); c.stroke();
            c.fillStyle = color; c.textAlign = 'left'; c.textBaseline = 'middle';
            c.fillText(text, pillX + pX, yPos); c.restore();
          }
        };

        profitChart = new Chart(ctx, {
          type: "line",
          plugins: [lineGlowPlugin, zeroLinePlugin, monthLinePlugin, currentLinePlugin, endLabelPlugin],
          data: {
            labels: dates,
            datasets: [{
              label: "Cumulative Profit (Units)",
              data: units,
              borderWidth: 2,
              fill: { target: { value: 0 } },
              backgroundColor: ctxArg => {
                const chart = ctxArg.chart;
                const {ctx: c2, chartArea, scales: {y}} = chart;
                if (!chartArea) return 'transparent';
                const gradient = c2.createLinearGradient(0, y.getPixelForValue(y.max), 0, y.getPixelForValue(y.min));
                const zeroPos = Math.max(0, Math.min(1, (y.max) / (y.max - y.min)));
                gradient.addColorStop(0, 'rgba(74, 222, 128, 0.22)');
                gradient.addColorStop(Math.max(0, zeroPos - 0.15), 'rgba(74, 222, 128, 0.06)');
                gradient.addColorStop(zeroPos, 'rgba(74, 222, 128, 0.01)');
                gradient.addColorStop(zeroPos, 'rgba(248, 113, 113, 0.01)');
                gradient.addColorStop(Math.min(1, zeroPos + 0.15), 'rgba(248, 113, 113, 0.06)');
                gradient.addColorStop(1, 'rgba(248, 113, 113, 0.22)');
                return gradient;
              },
              tension: 0.15,
              pointRadius: dr,
              pointHoverRadius: dh,
              pointBackgroundColor: units.map(v => v === 0 ? "#666" : v < 0 ? "#f87171" : "#4ade80"),
              pointBorderColor: units.map(v => v === 0 ? "#666" : v < 0 ? "#f87171" : "#4ade80"),
              pointBorderWidth: 0,
              segment: {
                borderColor: c => {
                  const y0 = c.p0.parsed.y, y1 = c.p1.parsed.y;
                  if (y0 < 0 && y1 < 0) return "#f87171";
                  if (y0 >= 0 && y1 >= 0) return "#4ade80";
                  return createZeroCrossingGradient(c.chart.ctx, y0, y1, c.chart.scales.y, false);
                }
              },
              order: 0
            },
            ...Object.entries(games).map(([gameName, data]) => {
              const color = gameColors[gameName] || '#888';
              const r = parseInt(color.match(/\d+/g)[0]);
              const g = parseInt(color.match(/\d+/g)[1]);
              const b = parseInt(color.match(/\d+/g)[2]);
              return {
                label: gameName,
                data: data,
                borderWidth: 1.5,
                borderColor: `rgba(${r}, ${g}, ${b}, 0.35)`,
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.15,
                spanGaps: false,
                pointRadius: 0,
                pointHoverRadius: dr + 1,
                pointBackgroundColor: `rgba(${r}, ${g}, ${b}, 0.5)`,
                pointBorderWidth: 0,
                borderDash: [4, 3],
                order: 1
              };
            })]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { top: 4, right: 4, bottom: 4, left: 4 } },
            interaction: { mode: 'index', intersect: false },
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: "rgba(22, 22, 22, 0.95)",
                titleColor: "#f0f0f0",
                bodyColor: "#e6e6e6",
                borderColor: "rgba(255,255,255,0.08)",
                borderWidth: 1,
                padding: { top: 10, bottom: 10, left: 14, right: 14 },
                cornerRadius: 8,
                displayColors: true,
                filter: item => {
                  if (item.datasetIndex > 0 && (item.parsed.y === 0 || item.parsed.y === null)) return false;
                  return true;
                },
                titleFont: { size: 12, weight: 600 },
                bodyFont: { size: 13 },
                callbacks: {
                  title: items => {
                    const d = items[0].label;
                    if (d === "Start") return d;
                    const [y,m,dd] = d.split("-");
                    return MONTH_NAMES[+m-1] + " " + +dd + ", " + y;
                  },
                  label: c => {
                    const val = c.parsed.y;
                    if (c.datasetIndex === 0) return "Overall: " + fmtSigned(val) + "u";
                    return c.dataset.label + ": " + fmtSigned(val) + "u";
                  }
                }
              }
            },
            scales: {
              x: { display: false, border: { display: false } },
              y: {
                position: 'right',
                grace: '5%',
                grid: {
                  color: ctxArg => ctxArg.tick.value === 0 ? 'transparent' : 'rgba(255,255,255,0.04)',
                  drawTicks: false
                },
                ticks: {
                  color: "#666",
                  font: { size: 11 },
                  callback: function(v) {
                    const lastVal = filteredUnits[filteredUnits.length - 1];
                    if (lastVal !== undefined) {
                      const range = this.max - this.min;
                      const threshold = range * 0.04;
                      if (Math.abs(v - lastVal) < threshold) return '';
                    }
                    return v === 0 ? "0" : (v > 0 ? "+" : "") + v.toFixed(1) + "u";
                  },
                  padding: 6
                },
                border: { display: false }
              }
            }
          }
        });
      }
      buildChart('ALL');
      document.querySelectorAll('.chart-range-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.chart-range-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          buildChart(btn.dataset.range);
        });
      });
    });

    async function populateSidebar() {
      const ul = document.getElementById("results-list");
      ul.innerHTML = "";
      try {
        const pages = await (await fetch("results.json")).json();
        const current = window.location.pathname.split("/").pop().replace(".html", "");
        pages.forEach(p => {
          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = p.file;
          a.textContent = p.label;
          if (p.file === current) a.classList.add("active");
          li.appendChild(a);
          ul.appendChild(li);
        });
      } catch (e) { console.error("Could not load results.json", e); }
    }

    function filterSidebar() {
      const filter = document.querySelector(".search-bar").value.toUpperCase();
      document.querySelectorAll(".sidebar ul li").forEach(li => {
        li.style.display = (li.textContent || li.innerText).toUpperCase().includes(filter) ? "" : "none";
      });
    }

    populateSidebar();
    document.querySelector(".search-bar").addEventListener("input", filterSidebar);
  </script>
</body>
</html>
